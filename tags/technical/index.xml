<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical on mjec&#39;s electric blogaloo</title>
    <link>https://mjec.blog/tags/technical/</link>
    <description>Recent content in Technical on mjec&#39;s electric blogaloo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 Jul 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://mjec.blog/tags/technical/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Australia should not adopt electronic voting</title>
      <link>https://mjec.blog/2016/07/11/australia-should-not-adopt-electronic-voting/</link>
      <pubDate>Mon, 11 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/07/11/australia-should-not-adopt-electronic-voting/</guid>
      <description>There has been a bunch of discussion about electronic voting recently, from the bipartisan political support to Dan Nolan&amp;rsquo;s nuanced take. As someone with an interest in election technology, I have a few thoughts.
I don&amp;rsquo;t actually want to get too deep into the technology side of this discussion. There are lots of great critiques of electronic voting technologies. There are also some great technologies: end-to-end systems which provide verification of each individual vote; blockchain systems which provide cryptographic evidence that results are not modified anywhere along the chain.</description>
    </item>
    
    <item>
      <title>Django&#39;s QuerySet union isn&#39;t quite what it seems</title>
      <link>https://mjec.blog/2016/06/27/djangos-queryset-union-isnt-quite-what-it-seems/</link>
      <pubDate>Mon, 27 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/06/27/djangos-queryset-union-isnt-quite-what-it-seems/</guid>
      <description>One of the websites I maintain is for the Tasmanian Debating Union. I built a competition management system, a rewrite in Django of a system originally designed and built in PHP by my friend Pat.
The database schema for this system includes a table with one row per debate. Those debates have associated teams (one affirmative, one negative) and an outcome (e.g. affirmative win, negative win). There&amp;rsquo;s therefore no single column to select the winning team.</description>
    </item>
    
    <item>
      <title>Your RDBMS has cool features</title>
      <link>https://mjec.blog/2016/06/26/your-rdbms-has-cool-features/</link>
      <pubDate>Sun, 26 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/06/26/your-rdbms-has-cool-features/</guid>
      <description>Aside: I started writing this post back in May, and have finally had a chance to finish it! Particular thanks to Benson who worked with me on the ultimate solution.
How did we get here? There&amp;rsquo;s a tendency in a lot of web development to be cautious of the data layer. We outsource persistence to the magic of PostgreSQL (or MySQL or MariaDB or SQL Server or Mongo or Redis or whatever) and just kind of ignore how it works.</description>
    </item>
    
    <item>
      <title>Non-proofs</title>
      <link>https://mjec.blog/2016/04/19/non-proofs/</link>
      <pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/04/19/non-proofs/</guid>
      <description>Today I read a thread of fake proofs on /r/math. The whole thread is great, but perhaps my favourite is the following &amp;ldquo;proof&amp;rdquo; I reproduce here.
We attempt to find:
$$\int \frac{1}{f} \frac{\mathrm{d}f}{\mathrm{d}x}$$
Let $\mathrm{d}u = - \frac{1}{f^2}\mathrm{d}x$ and $v = f$.
Then we use the ordinary method of integration by parts:
$$\int u \mathrm{d}v = uv - \int v \mathrm{d}u$$
Substituting:
$$\int \frac{1}{f} \mathrm{d}f = \frac{1}{f}f - \int f - \frac{1}{f^2} \mathrm{d}f$$</description>
    </item>
    
    <item>
      <title>An idea for trusted brute-force-resistant two-factor-authenticated full disk encryption</title>
      <link>https://mjec.blog/2016/04/15/an-idea-for-trusted-brute-force-resistant-two-factor-authenticated-full-disk-encryption/</link>
      <pubDate>Fri, 15 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/04/15/an-idea-for-trusted-brute-force-resistant-two-factor-authenticated-full-disk-encryption/</guid>
      <description>I was privileged to see Matthew Garrett&amp;rsquo;s talk at LCA this year on tpmtotp. This is software which enables you to verify that your computer hardware has not been tampered with before you are required to enter your full disk encryption password. It does this by sealing the TOTP secret in the TPM against a particular set of platform control register values. This means that if any aspect of the boot configuration changes the secret cannot be unsealed, so an attacker cannot pretend to be you.</description>
    </item>
    
    <item>
      <title>My Haskell was slow</title>
      <link>https://mjec.blog/2016/04/12/my-haskell-was-slow/</link>
      <pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/04/12/my-haskell-was-slow/</guid>
      <description>I have a Haskell function that builds frequency tables. It is very slow (and not very good). Originally this post was to look at why, and try to find a way to speed it up.
It turns out that GHC (the Haskell compiler) includes some nice profiling tools. You can set &amp;ldquo;cost centres&amp;rdquo; you want to look at using the {-# SCC &amp;quot;cost-centre-name&amp;quot; #-} pragma. So that&amp;rsquo;s what I did, and I have ended up with this:</description>
    </item>
    
    <item>
      <title>Finding subsets with particular sums</title>
      <link>https://mjec.blog/2016/04/11/finding-subsets-with-particular-sums/</link>
      <pubDate>Mon, 11 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/04/11/finding-subsets-with-particular-sums/</guid>
      <description>On Friday I came in on the tail end of a conversation explaining the solution to this problem. I think it&amp;rsquo;s pretty interesting.
Given a list of integers L and a target sum S, what&amp;rsquo;s the best way to find the pair x, y where x and y are both distinct elements of L such that x + y = S? We also want to be able to determine if there is no such pair.</description>
    </item>
    
    <item>
      <title>Fibonacci numbers and the golden ratio</title>
      <link>https://mjec.blog/2016/04/07/fibonacci-numbers-and-the-golden-ratio/</link>
      <pubDate>Thu, 07 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/04/07/fibonacci-numbers-and-the-golden-ratio/</guid>
      <description>SICP is one of the standard books people study at RC. It&amp;rsquo;s definitely pretty cool, and something I&amp;rsquo;ve had a bit of experience with since getting half way through the 1986 lectures based on the book.
We have a study group for SICP that I have been involved with. Today one of the problems we looked at was 1.13, which is as follows:
 Prove that $Fib(n)$ is the closest integer to $\frac{\phi^n}{\sqrt{5}}$, where $\phi = \frac{1 + \sqrt{5}}{2}$.</description>
    </item>
    
    <item>
      <title>Learning Haskell</title>
      <link>https://mjec.blog/2016/03/30/learning-haskell/</link>
      <pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mjec.blog/2016/03/30/learning-haskell/</guid>
      <description>I was surprised to hear that Haskell isn&amp;rsquo;t really a functional language so much as it&amp;rsquo;s a strongly typed one. I was of course aware that it had both these properties but it took really using it to see why the typing was so important.
I started on Monday afternoon with Learn You A Haskell. It&amp;rsquo;s pretty good. That, combined with a couple of group discussions sessions, has meant I&amp;rsquo;m feeling pretty confident.</description>
    </item>
    
  </channel>
</rss>